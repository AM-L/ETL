/// @file ratio
/// @data 03/06/2016 21:23:53
/// @author Ambroise Leclerc
/// @brief Compile-time rational arithmetic
//
// Copyright (c) 2016, Ambroise Leclerc
//   All rights reserved.
//
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in
//     the documentation and/or other materials provided with the
//     distribution.
//   * Neither the name of the copyright holders nor the names of
//     contributors may be used to endorse or promote products derived
//     from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
//  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
//  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
//  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
//  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
#pragma once
#include <libstd/include/type_traits>

namespace std {

namespace etlHelper {
    template<intmax_t A, intmax_t B> struct PGCD { static const intmax_t value = PGCD<B, A%B>::value; };
    template<intmax_t A>             struct PGCD<A, 0> { static const intmax_t value = A; };
    template<>                       struct PGCD<0, 0> { static const intmax_t value = 1; };

    template<intmax_t A, intmax_t B> struct PPCM { static const intmax_t value = A / PGCD<A, B>::value * B; };
    template<intmax_t X>             struct Abs { static const intmax_t value = X < 0 ? -X : X; };
    template<intmax_t X>             struct Sign { static const intmax_t value = X == 0 ? 0 : (X < 0 ? -1 : 1); };
} // namespace etlHelper

template<intmax_t Num, intmax_t Denom = 1>
class ratio {
public:
    using type = ratio<Num, Denom>;
    static constexpr intmax_t num = (etlHelper::Sign<Num>::value * etlHelper::Sign<Denom>::value) * etlHelper::Abs(Num)::value / etlHelper::PGCD<etlHelper::Abs<Num>::value, etlHelper::Abs<Denom>::value>::value;
    static constexpr intmax_t den = etlHelper::Abs(Denom)::value / etlHelper::PGCD<etlHelper::Abs<Num>::value, etlHelper::Abs<Denom>::value>::value;
};

using atto 	= ratio<1, 1000000000000000000>;
using femto = ratio<1, 1000000000000000>;
using pico 	= ratio<1, 1000000000000>;
using nano 	= ratio<1, 1000000000>;
using micro = ratio<1, 1000000>;
using milli = ratio<1, 1000>;
using centi = ratio<1, 100>;
using deci 	= ratio<1, 10>;
using deca 	= ratio<10, 1>;
using hecto = ratio<100, 1>;
using kilo 	= ratio<1000, 1>;
using mega 	= ratio<1000000, 1>;
using giga 	= ratio<1000000000, 1>;
using tera 	= ratio<1000000000000, 1>;
using peta 	= ratio<1000000000000000, 1>;
using exa 	= ratio<1000000000000000000, 1>;

namespace etlHelper {
    template<typename T>                    struct is_ratio : false_type {};
    template<intmax_t Num, intmax_t Denom>  struct is_ratio<ratio<Num, Denom>> : true_type {};
} // namespace etlHelper



} // namespace std