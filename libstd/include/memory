/// @file memory
/// @data 05/03/2014 18:23:53
/// @author Ambroise Leclerc
/// @brief
//
// Copyright (c) 2014, Ambroise Leclerc
//   All rights reserved.
//
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in
//     the documentation and/or other materials provided with the
//     distribution.
//   * Neither the name of the copyright holders nor the names of
//     contributors may be used to endorse or promote products derived
//     from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
//  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
//  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
//  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
//  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.

#pragma once
#include <../libstd/include/utility>
#include "h/unique_ptr.h"


namespace std {
namespace etlHelper {
// addressof helpers taken from Boost library
template<typename T> struct addressof_ref {
    T & v_;
    addressof_ref(T & v) : v_(v) {}
    operator T& () const { return v_; }

private:
    addressof_ref & operator=(const addressof_ref &);
};

template<typename T> struct addressof_impl {
    static T * f(T & v, long) {
        return reinterpret_cast<T*>(&const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
    }
    static T * f(T * v, int) { return v; }
};

} //namespace etlHelper

template<typename T>
class allocator {
public:
    using value_type = T;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using propagate_on_container_move_assignment = std::true_type;

    template<typename T2> struct rebind { typedef allocator<T2> other; };

    allocator() noexcept {}
    allocator(const allocator&) noexcept {};
    template<typename T2> allocator(const allocator<T2>&) noexcept {};

    /// Constructs an object of type T in allocated uninitialized storage using placement new.
    template<typename T2, typename... Args>
    static void construct(T2* p, Args&&... value) {
        ::new(reinterpret_cast<void*>(p)) T2(std::forward<Args>(value)...);
    }

    // destroy helper to invoke destructor explicitly.
    static void destroy(const_reference t) {
        t.~T(); // T must support non-throwing destructor
    }
};

template<typename T> T* addressof(T& arg) {
    return etlHelper::addressof_impl<T>::f(etlHelper::addressof_ref<T>(arg), 0);
}

namespace etlHelper {
    class refCounter {
        long count;
    public:
        refCounter() : count(1) { }
        virtual ~refCounter() = default;

        void inc() { ++count; }
        void dec() { --count; }
        long use_count() const { return count; }
    };

    template<typename T> struct refCountAndPointer : refCounter {
        T* pointee;
        explicit refCountAndPointer(T* p) : pointee(p) { }
        ~refCountAndPointer() override { delete pointee; }
    };

    template<typename T> struct refCountAndObject : refCounter {
        T object;
        template<typename ... Args> refCountAndObject(Args && ...args) : object(args...) { }
    };

} //namespace etlHelper

template<typename T>
class shared_ptr {
public:
    using element_type = T;

    constexpr shared_ptr() : pointee(nullptr), counter(nullptr) {}
    constexpr shared_ptr(std::nullptr_t) : pointee(nullptr), counter(nullptr) {}
    explicit shared_ptr(T* p) { createCounter(p); }
    template <typename U> shared_ptr(const shared_ptr<U>& ptr) { *this = other; }
    shared_ptr(const shared_ptr& ptr) : counter(ptr.counter), pointee(ptr.pointee) { if (use_count() > 0) counter->inc(); }
    ~shared_ptr()       { release(); }

    void reset()        { release(); }
    void reset(T* p)    { release(); createCounter(p); }

    shared_ptr& operator=(const shared_ptr& rhs) { 
        release();
        pointee = rhs.pointee;
        counter = rhs.counter;
        return *this;
    }

    void swap(shared_ptr& lhs) {
        std::swap(pointee, lhs.pointee);
        std::swap(counter, lhs.counter);
    }

    operator bool()     const { return pointee != nullptr; }
    bool unique()       const { return 1 == use_count(); }
    long use_count()    const { return counter ? counter->use_count() : 0; }
    T& operator*()      const { return *pointee; }
    T* operator->()     const { return pointee; }
    T* get(void)        const { return pointee; }

private:
    void createCounter(T* p) {
        auto tmp = new etlHelper::refCountAndPointer(p);
        pointee = tmp->pointee;
        counter = tmp;
    }

    void release() {
        if (counter) {
            counter->dec();
            if (0 == counter->use_count()) {
                delete counter;
            }
            counter = nullptr;
        }
        pointee = nullptr;
    }

private:
    template<typename U> friend class shared_ptr;
    template<typename T1, typename... Args> friend shared_ptr<T1> make_shared(Args&&... args);
    T*                      pointee;
    etlHelper::refCounter*  counter;
};


template<typename T, typename U> bool operator==(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() == r.get()); }
template<typename T, typename U> bool operator!=(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() != r.get()); }
template<typename T, typename U> bool operator<=(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() <= r.get()); }
template<typename T, typename U> bool operator<(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() < r.get()); }
template<typename T, typename U> bool operator>=(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() >= r.get()); }
template<typename T, typename U> bool operator>(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() > r.get()); }
template<typename T, typename U>shared_ptr<T> static_pointer_cast(const shared_ptr<U>& ptr) {
    return shared_ptr<T>(ptr, static_cast<typename shared_ptr<T>::element_type*>(ptr.get()));
}

template<typename T, typename ... Args> shared_ptr<T> make_shared(Args && ... args) {
    shared_ptr<T> ptr;
    auto tmp = new etlHelper::refCountAndObject<T>(args...);
    ptr.pointee = &tmp->object;
    ptr.counter = tmp;

    return ptr;
}

} // namespace std
