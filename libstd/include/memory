/// @file memory
/// @data 05/03/2014 18:23:53
/// @author Ambroise Leclerc
/// @brief
//
// Copyright (c) 2014, Ambroise Leclerc
//   All rights reserved.
//
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in
//     the documentation and/or other materials provided with the
//     distribution.
//   * Neither the name of the copyright holders nor the names of
//     contributors may be used to endorse or promote products derived
//     from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
//  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
//  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
//  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
//  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.

#pragma once
#include <../libstd/include/utility>
#include "h/unique_ptr.h"


namespace std {
namespace etlHelper {
// addressof helpers taken from Boost library
template<typename T> struct addressof_ref {
    T & v_;
    addressof_ref(T & v) : v_(v) {}
    operator T& () const { return v_; }

private:
    addressof_ref & operator=(const addressof_ref &);
};

template<typename T> struct addressof_impl {
    static T * f(T & v, long) {
        return reinterpret_cast<T*>(&const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
    }
    static T * f(T * v, int) { return v; }
};


class refCounter {
public:
    refCounter() : refCount(nullptr) {}
    refCounter(const refCounter& count) : refCount(count.refCount) {}
    void swap(refCounter& lhs) { std::swap(refCount, lhs.refCount); }
    
    uint16_t use_count() const {
        uint16_t count = 0;
        if (nullptr != refCount) {
            count = *refCount;
        }
        return count;
    }
    
    template<typename T> void acquire(T* p) {
        if (nullptr != p) {
            if (nullptr == refCount) {
                refCount = new long(1);
            }
        }
        else {
            ++(*refCount);
        }
    }

    template<typename T> void release(T* p) {
        if (nullptr != refCount) {
            --(*refCount);
            if (0 == *refCount) {
                delete p;
                delete refCount;
            }
            refCount = nullptr;
        }
    }

    uint16_t* refCount;
};

template<typename T> struct refCountAndObject : refCounter {
    T object;
    template<typename ... Args> refCountAndObject(Args && ...args) : object(args...) { }
    virtual void dispose() { }
};

} //namespace etlHelper

template<typename T>
class allocator {
public:
    using value_type = T;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using propagate_on_container_move_assignment = std::true_type;

    template<typename T2> struct rebind { typedef allocator<T2> other; };

    allocator() noexcept {}
    allocator(const allocator&) noexcept {};
    template<typename T2> allocator(const allocator<T2>&) noexcept {};

    /// Constructs an object of type T in allocated uninitialized storage using placement new.
    template<typename T2, typename... Args>
    static void construct(T2* p, Args&&... value) {
        ::new(reinterpret_cast<void*>(p)) T2(std::forward<Args>(value)...);
    }

    // destroy helper to invoke destructor explicitly.
    static void destroy(const_reference t) {
        t.~T(); // T must support non-throwing destructor
    }
};

template<typename T> T* addressof(T& arg) {
    return etlHelper::addressof_impl<T>::f(etlHelper::addressof_ref<T>(arg), 0);
}


template<typename T>
class shared_ptr {
public:
    using element_type = T;

    shared_ptr() throw() : pointee(nullptr), counter() {}
    explicit shared_ptr(T* p) : counter() { acquire(p); }
    template <typename U> shared_ptr(const shared_ptr<U>& ptr, T* p) : counter(ptr.count) { acquire(p); }
    template <typename U> shared_ptr(const shared_ptr<U>& ptr) : counter(ptr.count) { acquire(static_cast<typename shared_ptr<T>::element_type*>(ptr.pointee)); }
    shared_ptr(const shared_ptr& ptr) : counter(ptr.counter) { acquire(ptr.pointee); }
    ~shared_ptr()       { release(); }

    void reset()        { release(); }
    void reset(T* p)    { release(); acquire(p); }
    shared_ptr& operator=(shared_ptr ptr) { swap(ptr);  return *this; }

    void swap(shared_ptr& lhs) {
        std::swap(pointee, lhs.pointee);
        counter.swap(lhs.counter);
    }

    operator bool()     const { return (0 < counter.use_count()); }
    bool unique()       const { return (1 == counter.use_count()); }
    long use_count()    const { return counter.use_count(); }
    T& operator*()      const { return *pointee; }
    T* operator->()     const { return pointee; }
    T* get(void)        const { return pointee; }

private:
    void acquire(T* p) {
        counter.acquire(p);
        pointee = p;
    }

    void release() {
        counter.release(pointee);
        pointee = nullptr;
    }

private:
    template<typename U> friend class shared_ptr;
    T*                      pointee;
    etlHelper::refCounter   counter;
};


template<typename T, typename U> bool operator==(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() == r.get()); }
template<typename T, typename U> bool operator!=(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() != r.get()); }
template<typename T, typename U> bool operator<=(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() <= r.get()); }
template<typename T, typename U> bool operator<(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() < r.get()); }
template<typename T, typename U> bool operator>=(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() >= r.get()); }
template<typename T, typename U> bool operator>(const shared_ptr<T>& l, const shared_ptr<U>& r) { return (l.get() > r.get()); }
template<typename T, typename U>shared_ptr<T> static_pointer_cast(const shared_ptr<U>& ptr) {
    return shared_ptr<T>(ptr, static_cast<typename shared_ptr<T>::element_type*>(ptr.get()));
}

template<typename T, typename ... Args> shared_ptr<T> make_shared(Args && ... args) {
    shared_ptr<T> ptr;
    auto tmpObject = new etlHelper::refCountAndObject<T>(args...);
    ptr._obj_ptr = &tmp_object->object;
    ptr._ref_counter = tmp_object;

    return ptr;
}

} // namespace std
